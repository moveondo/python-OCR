### 垃圾回收

Python中的垃圾回收是以引用计数为主，分代收集为辅。引用计数的缺陷是循环引用的问题。

在Python中，如果一个对象的引用数为0，Python虚拟机就会回收这个对象的内存。

>导致引用计数+1的情况

对象被创建，例如a=23

对象被引用，例如b=a

对象被作为参数，传入到一个函数中，例如func(a)

对象作为一个元素，存储在容器中，例如list1=[a,a]

>导致引用计数-1的情况

对象的别名被显式销毁，例如del a

对象的别名被赋予新的对象，例如a=24

一个对象离开它的作用域，例如f函数执行完毕时，func函数中的局部变量（全局变量不会）

对象所在的容器被销毁，或从容器中删除对象


>其他

如果循环引用中，两个对象都定义了__del__方法，gc模块不会销毁这些不可达对象，因为gc模块不知道应该先调用哪个对象的__del__方法，所以为了安全起见，gc模块会把对象放到gc.garbage中，但是不会销毁对象。

>应用

项目中避免循环引用

引入gc模块，启动gc模块的自动清理循环引用的对象机制

由于分代收集，所以把需要长期使用的变量集中管理，并尽快移到二代以后，减少GC检查时的消耗

gc模块唯一处理不了的是循环引用的类都有__del__方法，所以项目中要避免定义__del__方法，如果一定要使用该方法，同时导致了循环引用，需要代码显式调用gc.garbage里面的对象的__del__来打破僵局


